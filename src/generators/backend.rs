// src/generators/backend.rs
use crate::templates::backend;
use crate::utils::fs as fs_utils;
use std::fs;

pub fn create_structure(project_name: &str) {
    let backend_path = format!("{}/backend", project_name);
    fs::create_dir_all(&backend_path).unwrap();

    // Create Rust project structure
    create_cargo_toml(&backend_path, project_name);
    create_source_structure(&backend_path);
    create_env_file(&backend_path);
}

fn create_source_structure(backend_path: &str) {
    let directories = vec![
        "src/db/migrations/versions",
        "src/graphql/mutations",
        "src/graphql/queries",
        "src/graphql/types",
        "src/entities",
        "src/repositories",
        "src/services",
        "src/utils",
    ];

    fs_utils::create_directories(backend_path, &directories);

    // Create initial source files
    create_main_file(backend_path);
    create_mod_files(backend_path);
}

fn create_cargo_toml(path: &str, project_name: &str) {
    fs::write(
        format!("{}/Cargo.toml", path),
        backend::get_cargo_toml_template(project_name),
    )
    .unwrap();
}

fn create_main_file(path: &str) {
    fs::write(
        format!("{}/src/main.rs", path),
        backend::get_main_rs_template(),
    )
    .unwrap();
}

fn create_env_file(path: &str) {
    fs::write(
        format!("{}/.env.example", path),
        backend::get_env_template(),
    )
    .unwrap();
}

fn create_mod_files(base_path: &str) {
    let mod_paths = [
        "src/db",
        "src/graphql",
        "src/entities",
        "src/repositories",
        "src/services",
        "src/utils",
    ];

    for path in mod_paths {
        fs::write(
            format!("{}/{}/mod.rs", base_path, path),
            "// Generated by Nebulis CLI\n",
        )
        .unwrap();
    }
}

pub fn generate_model(name: &str) {
    println!("Generating model: {}", name);
    // TODO: Implement model generation
}

pub fn generate_migration(name: &str) {
    println!("Generating migration: {}", name);
    // TODO: Implement migration generation
}

pub fn generate_resolver(name: &str) {
    println!("Generating resolver: {}", name);
    // TODO: Implement resolver generation
}
